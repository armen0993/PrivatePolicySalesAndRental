So today we are working with this kind of data to display the stories :
"displays": [{
        "displayId": "azerty",
        "tags": ["IMAGE", "1N2"],
        "targets": ["BETIN_LIVE_FEED", "BetinMedia"],
        "layers": [{
            "zPosition": 1,
            "type": "image",
            "media": "https://firebasestorage.googleapis.com/v0/b/pturf-apps-firebase-dev.appspot.com/o/tests_betin%2Ffederernadal_2.jpeg?alt=media&token=2cb923b7-412e-4e5c-b854-632d22b5252d"        }, {
            "zPosition": 2,
            "type": "text",
            "media": "Qui sera le vainqueur ?!",
            "uiStyle": {
              "height": 5,
              "width": 75,
              "vPosition": "TOP",
              "hPosition": "CENTER",
              "maxFontSize": 35,
              "backColor":"#000000",
              "frontColor":"#FFFFFF"            }
        }, {
              "zPosition": 3,
              "type": "text",
              "media": "Federer ou\r\nNADAL ?",
              "uiStyle": {
                "height": 15,
                "width": 100,
                "vPosition": "TOP",
                "hPosition": "CENTER",
                "vOffset": 5.5,
                "maxFontSize": 25,
                "frontColor":"#FF003F",
                "backColor": "#09BB98",
                "highlightColor": "#5455F2",
                "allowsMultiline": true              }
        }],
        "topings": [{
            "type":"MAINBET",
            "actionType":"EXTLINK",
            "uri":"https://www.pmu.fr/",
            "combinationSlug":"federerwins",
            "position": "BOTTOMQUARTER"        }]
}]
It allows to display a list of elements and topings.
In the future, they want to have a more dynamic system which allows to display and hide some elements / topings at certain points during the story.
We have a bit think about it and we have worked on a proper way to do it.
We think that a system based on a tick each second could work.
When the story starts, a timer starts to and run a callback each second. This callback will check if at the current second there are elements / topings to show or hide.
So we should receive this kind of data instead :
14:56
"displays":[ // contains the elements describing the template to use and parameterize the display of the offers. We can have multiple display possible depending to the chanel etc    {
      "tags": ["VIDEO","1N2"], // tags to categorize the graphical template      "displayId":"",
      "target":["BetinLive","BetinMedia"], // distribution channel allowed to show this template        "backgroundsTicked": [
      { // stacking of the layers which contains all the elements to be shown        "type": "color | video", // content type which will be displayed on the layer : video, text, image, webview        "media":"#FF000FF | http://cdn....", // the url to the content or the text content        "startTime": 0,
        "endTime": 10      },
      {
        "type": "color | video", // content type which will be displayed on the layer : video, text, image, webview        "media":"#FF000FF | http://cdn....", // the url to the content or the text content        "startTime": 10,
        "endTime": 20      }
    ],
    "layersTicked":[
      {
        "Zposition":1,
        "type": "texte",
        "media":"Remontada du Real",
        "startTime": 5,
        "endTime": 15,
        "uiStyle":{ // used to custom the layer (position, size, color, orientation, etc.)          "height":10, // the height of the element - X%          "width":20, // the width of the element - X%          "vPosition":"TOP, BOTTOM, CENTER, TOPQUARTER, BOTTOMQUARTER", // the position of the element on the Y axis. We have decided to split the screen into 5 verticals zones. Content is centered inside its view          "hPosition":"CENTER, RIGHT, LEFT", // the position of the element on the X axis. We have decided to split the screen into 3 horizontals zones. LEFT = the content is aligned to the left of its view; RIGHT = the content is aligned to the right; CENTER = the content is centered          "backcolor":"green", // the background color of the content. By default the background is transparent          "rotation": 0, // allows the display of the content with an angle (from 0 to 360)          // Attributes for text layers only          "frontcolor":"blue", // the text color          "maxFontSize":30, // the maximum size for the font          "font":"openSans", // the font selected from a defined liste => Optional          "style":["Bold, underline"...] // the emphasis applied to the text        }
      }
    ],
    "topingsTicked":[{//il s'agit des call to action a activer      "type":"MAINBET, SECONDARYBET,GOTO", //indique de quel type de CTA on parle. ca aura une incidence sur l'UI      "actionType":"BETSLIP, NAVIGATE, DEEPLINK, EXTDEEPLINK", // indique ce que devra faire l'app qui gere le clic      "uri":".....",
      "combinationSlug":"realwin", // revoie la reference de l'offre associ√© a ce call to action      "startTime": 0,
      "endTime": 20    }]
}]
14:56
It should be globally the same, but there are 2 new properties :
startTime : It is the second at which the element has to be shown (0 is for the beginning / 5 is at 5 second (5 ticks) from the beginning etc)
endTime : It is the second at which the element has to be hidden.
Of course it should always have a background so the duration of the whole should be the max value of endTime inside the background array.
So we want to test how we can implement this in the BetFeed.